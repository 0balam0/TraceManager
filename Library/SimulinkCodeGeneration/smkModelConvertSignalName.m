function [tTH,cStr_for_gof,cstr_from_dll,cStr_signame]=smkModelConvertSignalName(tStr,len)
pattern_um='_u';
pattern_sign='_S_';
index=0;
correspondence={'rad/s' 'rad_s';...
                'km/h' 'km_h';...
                'm/s' 'm_s';...
                'rad/s^2' 'rad_s2';...
                'm/s^2' 'm_s2';...
                'm/s^3' 'm_s3';...
                'm^2/s' 'm2_s';...
                'mm^2/s' 'mm2_s';...
                'Pa*s' 'Pa_s';...
                '°C' 'degC';...
                'J/kgK' 'J_kgK';...
                'kJ/kgK' 'kJ_kgK';...
                'W/m^2K' 'W_m2K';...
                'W/mK' 'W_mK';...
                'W/m2' 'W_m2';...
                '%' 'perc';...
                '1/h' '1_h';...
                'Mp/s' 'Mp_s';...
                '1/s' '1_s';...
                'g/s' 'g_s';...
                'g/h' 'g_h';...
                'kg/s' 'kg_s';...
                'kg/h' 'kg_h';...
                'mm^3' 'mm3';...
                'cm^3' 'cm3';...
                'dm^3' 'dm3';...
                'm^3' 'm3';...
                'mm^3/s' 'mm3_s';...
                'cm^3/s' 'cm3_s';...
                'dm^3/s' 'dm3_s';...
                'm^3/s' 'm3_s';... 
                'mm^3/h' 'mm3_h';...
                'cm^3/h' 'cm3_h';...
                'dm^3/h' 'dm3_h';...
                'm^3/h' 'm3_h';... 
                'g/l' 'g_l';...
                'g/m^3' 'g_m3';...
                'g/m3' 'g_m3';...
                'kg/m^3' 'kg_m3';...
                'kg/m3' 'kg_m3';...
                'Mp/m^3' 'Mp_m3';...
                'mm^2' 'mm2';...
                'cm^2' 'cm2';...
                'dm^2' 'dm2';...
                'm^2' 'm2';...
                'J/Kg' 'J_Kg';...
                'MJ/Kg' 'MJ_Kg';...
                'l/km' 'l_km';...
                'l/100km' 'l_100km';...
                'g/km' 'g_km';...
                'Km/l' 'Km_l';...
                'g/kWh' 'g_kWh';...
                'g/CVh' 'g_CVh';...
                'mg/cc' 'mg_cc';...
                'rpm/s' 'rpm_s';...
                'Nm^05/rpm' 'Nm05_rpm';...
                '0/1' '0_1'};
            
tStr=rmfield(tStr,'M_out');
cstr_from_dll=fieldnames(tStr);
cStr_for_gof=cell(length(cstr_from_dll),1);

k_s=strfind(cstr_from_dll,pattern_sign);% identify the index of the pattern to split the string and to identify 
k_u=strfind(cstr_from_dll,pattern_um);  % the signal name, the group name(bus name), and the unit of measurement(-> if present)
j=1;

for i=1:length(cstr_from_dll)
    k_sign=k_s{i};
    k_um=k_u{i};
    str_i=cstr_from_dll{i};
    group=str_i(1:k_sign-1);
    value=fields2mat(tStr,str_i); 
    
    if ~isempty(k_sign)
        UM=str_i([k_um+3:length(str_i)]);
        str_i(k_um:length(str_i))=[];
        str_i([1:k_sign+2])=[];
        
        if ~isempty(UM)%%%Also the strings of unit of measurement, in some cases need to be converted. There are signal without UM.    
            idx_um=strcmpi(UM,correspondence(:,2));
            corr=correspondence(idx_um,1);
            if ~isempty(corr)
                UM=corr;
                UM=UM{1};
            end
            cStr_for_gof(j)={[str_i,' [',UM,']']};
            tTH.(str_i).u=UM;
            j=j+1;
            
        else
            cStr_for_gof(j)={str_i};
            tTH.(str_i).u='-';
            j=j+1;
        end
        if ~iscell(value) %add signal to be a tTH field. Pre-allocating the vector of value. 
           
            tTH.(str_i).v=zeros(len,1);
            tTH.(str_i).v(1)=value;
            tTH.(str_i).d=group;
            
        else
            index(length(index)+1)=i; %save the intex of the signal that is not scalar value.
        end
    else
        nome_bus=str_i(i); %only for debug purpose.
    end
    cStr_signame(j-1)={str_i};
end
index=index(2:end)';
k=0;
for i=1:length(index) %cut the signals with the vector as value
    cstr_from_dll{(index(i))-k}=[];
    cstr_from_dll((index(i))-k)=[];
    cStr_signame{(index(i))-k}=[];
    cStr_signame((index(i))-k)=[];
    cStr_for_gof{(index(i))-k}=[];
    cStr_for_gof((index(i))-k)=[];
    k=i; 
end
%  the vector of time is kept as out value of the model, no more need to
%  build the time vector.
%     tTH.('builded_time').v=[timestep:Dt_postCalc:nCycle]';
%     tTH.('builded_time').u='s';
return